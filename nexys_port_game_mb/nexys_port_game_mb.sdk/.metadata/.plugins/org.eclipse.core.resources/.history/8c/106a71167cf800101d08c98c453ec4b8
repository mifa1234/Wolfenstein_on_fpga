/******************************************************************************
*
* Copyright (C) 2009 - 2014 Xilinx, Inc.  All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* Use of the Software is limited solely to applications:
* (a) running on a Xilinx device, or
* (b) that interact with a Xilinx device through a bus or interconnect.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
* XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
* Except as contained in this notice, the name of the Xilinx shall not be used
* in advertising or otherwise to promote the sale, use or other dealings in
* this Software without prior written authorization from Xilinx.
*
******************************************************************************/

/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */

#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
#include "xil_io.h"
#include "xaxidma.h"
#include "xintc.h"
#include "xil_exception.h"
#include <string.h> // Для memset
#include "xil_cache.h"


#include "SDL.h"
#include <sys/stat.h>

#define VALUE_BASE_ADDR_FRAME_BUFFER XPAR_AXI_BRAM_CTRL_0_S_AXI_BASEADDR


//    config_wl6.h
//    vgadict_wl6.h
//    vgagraph_wl6.h
//    vgahead_wl6.h
//    audiohed_wl6.h
//    audiot_wl6.h
//    vswap_wl6.h
//    gamemaps_wl6.h
//    maphead_wl6.h


// Правильные заглушки для функций джойстика
int SDL_NumJoysticks(void) { return 0; }
void SDL_JoystickUpdate(void) {}
Sint16 SDL_JoystickGetAxis(SDL_Joystick* joy, int axis) { return 0; }
Uint8 SDL_JoystickGetButton(SDL_Joystick* joy, int button) { return 0; }
Uint8 SDL_JoystickGetHat(SDL_Joystick* joy, int hat) { return 0; }
SDL_Joystick* SDL_JoystickOpen(int index) { return NULL; }
void SDL_JoystickClose(SDL_Joystick* joy) {}
int SDL_JoystickNumButtons(SDL_Joystick* joy) { return 0; }
int SDL_JoystickNumHats(SDL_Joystick* joy) { return 0; }

// Заглушка для mkdir
int mkdir(const char* path, mode_t mode) { return -1; }



#define FRAME_WIDTH		640
#define FRAME_HEIGHT	480
#define LUT_SIZE 512

// Таблица синуса/косинуса (1024 значения, 0..2π)
int8_t fast_sin(float x) {
    // Приводим x к диапазону [0, 2π]
    x = fmod(x, 6.283185307f);
    // Простая аппроксимация: sin(x) ≈ x - x^3/6 + x^5/120
    float x2 = x * x;
    float x3 = x2 * x;
    float x5 = x3 * x2;
    float sin_x = x - x3/6.0f + x5/120.0f;
    return (int8_t)(127.5f * sin_x);
}

// Быстрая аппроксимация cos(x) для x в диапазоне [0, 2π]
// Возвращает значение в диапазоне [-128, 127]
int8_t fast_cos(float x) {
    // cos(x) = sin(x + π/2)
    return fast_sin(x + 1.570796327f);
}

float fast_sqrt(float x) {
    union {
        int i;
        float f;
    } u;
    u.f = x;
    u.i = (1 << 29) + (u.i >> 1) - (1 << 22);
    return u.f;
}

struct line_f{
	uint16_t pixels[FRAME_WIDTH];
};

uint32_t *base_addr_frame_buffer = VALUE_BASE_ADDR_FRAME_BUFFER;


// Экземпляр контроллера прерываний
XIntc InterruptController;

XAxiDma_Config *dma_cfg;
XAxiDma dma_ctrl;
uint16_t *buffer_frame = XPAR_MIG_7SERIES_0_BASEADDR + 0x5000000; //XPAR_AXI_BRAM_CTRL_0_S_AXI_BASEADDR;

//struct line_f *buff_bram = XPAR_AXI_BRAM_CTRL_0_S_AXI_BASEADDR;
struct line_f buff_bram;
struct line_f *buff_ddr  = XPAR_MIG_7SERIES_0_BASEADDR + 0x5000000;

uint32_t counter_send_frame = 0, cnt_false_call_irq_dma = 0;

// Обработчик прерывания (ISR) для DMA MM2S. он перезапускается в конце каждого фрейма. конец фрейма обсуловлен размером отправки пакета. 640*480*2 байт.
void ReLaunch_DmaMm2sIsr(void *CallbackRef) {
	//xil_printf("n");

	Xil_Out32(XPAR_AXI_DMA_0_BASEADDR+0x04, 0x00001000);//MM2S_DMASR
	//

	if(base_addr_frame_buffer[0]!= 0){
		XAxiDma_SimpleTransfer(&dma_ctrl, base_addr_frame_buffer[0], FRAME_WIDTH*FRAME_HEIGHT*2, XAXIDMA_DMA_TO_DEVICE);
	} else {
		XAxiDma_SimpleTransfer(&dma_ctrl, buffer_frame, FRAME_WIDTH*FRAME_HEIGHT*2, XAXIDMA_DMA_TO_DEVICE);
	}

	//

	//blink led? end frame
	if(counter_send_frame >= 30){
		counter_send_frame = 0;
		//blink led0.
		uint8_t tmp_leds = Xil_In32(XPAR_AXI_GPIO_LEDS_BASEADDR);
		if(tmp_leds&0x01){
			tmp_leds = tmp_leds & 0xfe;
		}else{
			tmp_leds++;
		}
		Xil_Out32(XPAR_AXI_GPIO_LEDS_BASEADDR,tmp_leds);
	} else {
		counter_send_frame++;
	}

}


void Init_Start_sendFrames()
{	//нужен первый запуск для старта запуска фреймов
	int stat = XAxiDma_SimpleTransfer(&dma_ctrl, buffer_frame, FRAME_WIDTH*FRAME_HEIGHT*2, XAXIDMA_DMA_TO_DEVICE);
}


void Init_Interrupt_system()
{
	//enable interrupt inside DMA
    uint32_t tmp_reg_dma = Xil_In32(XPAR_AXI_DMA_0_BASEADDR+0x00);
    tmp_reg_dma = tmp_reg_dma | 0x00001000;
    Xil_Out32(XPAR_AXI_DMA_0_BASEADDR+0x00, tmp_reg_dma);

    int Status;
	xil_printf("XIntc_Initialize(&InterruptController, INTC_DEVICE_ID)\n\r");
    // Инициализация контроллера прерываний
    Status = XIntc_Initialize(&InterruptController, XPAR_AXI_INTC_0_DEVICE_ID);
    // Подключение обработчика прерывания к контроллеру
    Status = XIntc_Connect(&InterruptController, XPAR_INTC_0_AXIDMA_0_VEC_ID,(XInterruptHandler)ReLaunch_DmaMm2sIsr, NULL);

    // Запуск контроллера прерываний в реальном режиме
    Status = XIntc_Start(&InterruptController, XIN_REAL_MODE); // XIN_REAL_MODE //XIN_INTC_NOCASCADE
    // Включение прерывания для вашего устройства
    XIntc_Enable(&InterruptController, XPAR_INTC_0_AXIDMA_0_VEC_ID);

    // Инициализация системы исключений
    Xil_ExceptionInit();
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)XIntc_InterruptHandler, &InterruptController);
    Xil_ExceptionEnable();

    Xil_Out32(XPAR_AXI_DMA_0_BASEADDR+0x04, 0x00001000); //очистка бита прерывания в дма.
}

void test_timer()
{
	uint32_t start_time = Xil_In32(XPAR_ANY_REG_SPACE_TIMER_BASEADDR);
	uint32_t second_time;
	uint32_t end_time = Xil_In32(XPAR_ANY_REG_SPACE_TIMER_BASEADDR);
	uint32_t div_time = Xil_In32(XPAR_ANY_REG_SPACE_TIMER_BASEADDR + 0x4);
	uint32_t cnt = 0;

	xil_printf("start_time: %d  divider_time: %d\n\r", start_time, 1<<div_time);

	//clear timer
	Xil_Out32(XPAR_ANY_REG_SPACE_TIMER_BASEADDR,0);
	start_time = Xil_In32(XPAR_ANY_REG_SPACE_TIMER_BASEADDR);

	xil_printf("start_time after clear: %d\n\r", start_time);



	while(cnt < 256){
		if(Xil_In32(XPAR_ANY_REG_SPACE_TIMER_BASEADDR) >= (100000000/(1<<div_time))){
			start_time = Xil_In32(XPAR_ANY_REG_SPACE_TIMER_BASEADDR);
			second_time = Xil_In32(XPAR_ANY_REG_SPACE_TIMER_BASEADDR + 0x8);
			Xil_Out32(XPAR_ANY_REG_SPACE_TIMER_BASEADDR,0);//clear
			xil_printf("%d: timer1:%d, timer2: %d  \n\r", cnt, start_time, second_time);
			cnt++;
		}
	}

}

int main()
{
    init_platform();
   // Xil_DCacheDisable();
   // disable_caches();

    base_addr_frame_buffer[0] = 0;

    uint16_t color, stat;

    dma_cfg = XAxiDma_LookupConfig(XPAR_AXI_DMA_0_DEVICE_ID);
    stat = XAxiDma_CfgInitialize(&dma_ctrl, dma_cfg);

//    while(1) {
//    	xil_printf("send 1\n\r");
//    	int byte = 0;
//    	while(byte != '1'){
//    		byte = inbyte();
//    		xil_printf("rcv: %c\n\r",byte);
//    	}
//
//    	SDL_Event event;
//    	uint32_t count_data = 0;
//    	do {
//    		count_data = SDL_PollEvent(&event);
//    		xil_printf("\t count_data: %x(%d), type: %d, state: %d, scancode: %d, keycode: %d \n\r",count_data, (count_data & 0xFFFF), event.type, event.key.state, event.key.keysym.scancode, event.key.keysym.sym );
//    	} while((count_data & 0xFFFF) > 0);
//    } //--SDL_CreateRGBSurfaceWithFormat(flags, width, height, depth, format); //WallRefresh




    xil_printf("%c new frame\n\r", 27);
    xil_printf("cLEAR_LEDs\n\r");
    Xil_Out32(XPAR_AXI_GPIO_LEDS_BASEADDR,0);
    base_addr_frame_buffer[0] = 0;

    //xil_printf("\t\t_ _ current addr in stack %x\n\r", &color);

    xil_printf("INIT data frame buffer\n\r");
	int i,j;
	for(i = 0; i <FRAME_HEIGHT/2; i++){
		//if(i%21 == 0) xil_printf("l %d\n\r", i);
		for(j = 0; j <FRAME_WIDTH/2; j++)
		{
			color = 0;
			//R
			if(j%10 == 0) color += 0x3ca0;
			if(i == 29) color += 0x3c00;
			//G
			if((j+i)%10 == 0) color += 0x03f0;
			else color += 0x00E0;
			//B
			if((i%20 == 0) || (i%20 ==1)) color += 0x001F;

			if(color == 0) color = 0x6318;

			buffer_frame[i*FRAME_WIDTH+j] = color;

			if(buffer_frame[i*640+j] != color)  xil_printf("bad color\n\r");
		}
	}



	Init_Interrupt_system();

    xil_printf("Hello World\n\r");

    //test_timer();

    xil_printf("send Frames\n\r");
    Init_Start_sendFrames();


    Xil_DCacheFlush();
   // enable_caches();


    xil_printf("start game \n\r");
    wolf_main(0, NULL);

	while(1)
	{

//		SDL_CreateWindow();
//		SDL_CreateRenderer();
//	    SDL_GetWindowSurface();

	}

    cleanup_platform();
    return 0;
}
